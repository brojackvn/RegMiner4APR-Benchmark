/*
 * Copyright 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
// JavaCC grammar specification for a Soy file.
//
// @author Kai Huang


// =================================================================================================
// Options
// =================================================================================================

options {
  JDK_VERSION = "1.7";
  STATIC = false;
  UNICODE_INPUT = true;
  DEBUG_TOKEN_MANAGER = false;
  DEBUG_PARSER = false;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
}


// =================================================================================================
// Parser class
// =================================================================================================


PARSER_BEGIN(SoyFileParser)

package com.google.template.soy.soyparse;

import com.google.common.base.CharMatcher;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicates;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.template.soy.base.SourceLocation;
import com.google.template.soy.base.internal.Identifier;
import com.google.template.soy.base.internal.IdGenerator;
import com.google.template.soy.base.internal.LegacyInternalSyntaxException;
import com.google.template.soy.base.internal.SoyFileKind;
import com.google.template.soy.base.internal.SoyFileSupplier.Version;
import com.google.template.soy.error.ErrorReporter.Checkpoint;
import com.google.template.soy.error.ErrorReporter;
import com.google.template.soy.error.SoyErrorKind;
import com.google.template.soy.exprparse.SoyParsingContext;
import com.google.template.soy.soytree.defn.HeaderParam;
import com.google.template.soy.soytree.AliasDeclaration;
import com.google.template.soy.soytree.CallBasicNode;
import com.google.template.soy.soytree.CallDelegateNode;
import com.google.template.soy.soytree.CallNode;
import com.google.template.soy.soytree.CallParamContentNode;
import com.google.template.soy.soytree.CallParamNode;
import com.google.template.soy.soytree.CallParamValueNode;
import com.google.template.soy.soytree.CommandTagAttribute;
import com.google.template.soy.soytree.CssNode;
import com.google.template.soy.soytree.DebuggerNode;
import com.google.template.soy.soytree.ForNode;
import com.google.template.soy.soytree.ForeachNode;
import com.google.template.soy.soytree.IfCondNode;
import com.google.template.soy.soytree.IfElseNode;
import com.google.template.soy.soytree.IfNode;
import com.google.template.soy.soytree.LetContentNode;
import com.google.template.soy.soytree.LetNode;
import com.google.template.soy.soytree.LetValueNode;
import com.google.template.soy.soytree.LogNode;
import com.google.template.soy.soytree.MsgFallbackGroupNode;
import com.google.template.soy.soytree.MsgHtmlTagNode;
import com.google.template.soy.soytree.MsgNode;
import com.google.template.soy.soytree.MsgPlaceholderNode;
import com.google.template.soy.soytree.MsgPluralCaseNode;
import com.google.template.soy.soytree.MsgPluralDefaultNode;
import com.google.template.soy.soytree.MsgPluralNode;
import com.google.template.soy.soytree.MsgSelectCaseNode;
import com.google.template.soy.soytree.MsgSelectDefaultNode;
import com.google.template.soy.soytree.MsgSelectNode;
import com.google.template.soy.soytree.NamespaceDeclaration;
import com.google.template.soy.soytree.PrintDirectiveNode;
import com.google.template.soy.soytree.PrintNode;
import com.google.template.soy.soytree.RawTextNode;
import com.google.template.soy.soytree.SoyFileNode;
import com.google.template.soy.soytree.SoyNode.MsgPlaceholderInitialNode;
import com.google.template.soy.soytree.SoyNode.StandaloneNode;
import com.google.template.soy.soytree.SoyNode.StatementNode;
import com.google.template.soy.soytree.SwitchCaseNode;
import com.google.template.soy.soytree.SwitchDefaultNode;
import com.google.template.soy.soytree.SwitchNode;
import com.google.template.soy.soytree.TemplateBasicNodeBuilder;
import com.google.template.soy.soytree.TemplateDelegateNodeBuilder;
import com.google.template.soy.soytree.TemplateNode.SoyFileHeaderInfo;
import com.google.template.soy.soytree.TemplateNode;
import com.google.template.soy.soytree.TemplateNodeBuilder;
import com.google.template.soy.soytree.XidNode;
import com.google.template.soy.types.SoyType;
import com.google.template.soy.types.SoyTypes;
import com.google.template.soy.types.ast.GenericTypeNode;
import com.google.template.soy.types.ast.NamedTypeNode;
import com.google.template.soy.types.ast.RecordTypeNode;
import com.google.template.soy.types.ast.TypeNode;
import com.google.template.soy.types.ast.UnionTypeNode;
import com.google.template.soy.types.SoyTypeRegistry;
import com.google.template.soy.types.primitive.ErrorType;
import com.google.template.soy.types.primitive.UnknownType;
import com.google.template.soy.types.primitive.NullType;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;
import javax.annotation.Nullable;

/**
 * This parser's specification is in SoyFileParser.jj, which is read by JavaCC and transformed
 * into SoyFileParser.java. To modify this parser, please edit SoyFileParser.jj. Do not edit
 * SoyFileParser.java directly.
 *
 * <p> Important: Do not use outside of Soy code (treat as superpackage-private).
 *
 * <pre>
 * This parser parses the following Soy file structure:
 *
 * 1. Delegate package (delpackage):
 *    + Optional.
 *    + The file must contain 0 or 1 delpackage declaration.
 *    + It must appear before the namespace declaration.
 *    + It must appear on its own line and start at the start of a line.
 *    Example:  {delpackage MySecretFeature}
 *
 * 2. Namespace:
 *    + The file must contain exactly one namespace declaration.
 *    + It must appear before any templates.
 *    + It must appear on its own line and start at the start of a line.
 *    Examples:
 *    {namespace boo.foo}
 *    {namespace boo.foo autoescape="..."}
 *
 * 3. Alias:
 *    + Alias declarations must appear after the namespace declaration.
 *    + They must appear before any templates.
 *    + Each must appear on its own line and start at the start of a line.
 *    Examples:
 *    {alias boo.foo.goo.moo}
 *    {alias boo.foo.goo.moo as zoo}
 *
 * 4. SoyDoc:
 *    + Starts with slash-star-star (/**) and ends with star-slash (*&#47;) like JavaDoc.
 *    + SoyDoc must appear on its own line(s) and start at the start of a line.
 *    + Currently recognizes two tags: "&#64;param keyName" and "&#64;param? optionalKeyName".
 *    Example:
 *    /**
 *     * &#64;param boo Something scary.
 *     * &#64;param? goo Something slimy (optional).
 *     *&#47;
 *
 * 5. Template:
 *    + Each template must be immediately preceded by a SoyDoc block.
 *    + The 'template' tag and the '/template' tag much each appear on its own line(s) and start
 *      at the start of a line.
 *    + The template content is parsed by TemplateParser.jj.
 *    Examples:
 *    /**
 *     * New style.
 *     * &#64;param boo Something scary.
 *     * &#64;param? goo Something slimy (optional).
 *     *&#47;
 *    {template .foo autoescape="..."}
 *      {msg desc=""}
 *        {$boo} has a friend named {$goo.firstName}.
 *      {/msg}
 *    {/template}
 *
 * 6. Misc:
 *    + Other than the items specified above, everything else is ignored.
 *    + SoyDoc blocks not immediately followed by a template are ignored.
 *    + The file must end with a newline.
 *
 * Template contents are parsed as follows:
 * Header:
 *
 * 1. Comments:
 *    + Comments are only allowed outside of Soy tags.
 *    + Standard "//" for a rest-of-line comment. Must appear at start of line or after a space.
 *    + Standard slash-star (/*) ... star-slash (*&#47;) for a block comment.
 *    + Doc comments are not allowed, except when attached to a valid declaration.
 *
 * 2. Param declaration:
 *    + Soy tag with command name "@param" and command text "key: type".
 *    + Optional desc string is written as a block doc comment, which either must
 *      precede the param tag, or must start on the same line as the end of the '@param' tag.
 *    + Examples:
 *    {@param foo: bool}
 *    {@param foo: list<int>}  /** A list of numbers. *&#47;
 *    {@param? foo:
 *        list<int>}  /**
 *        A list of numbers. *&#47;
 *
 * 3. Injected param declaration:
 *    + Works exactly like @param except that parameter values are taken from the
 *      implicit $ij scope.
 *    + Soy tag with command name "@inject" and command text "key: type".
 *    + Optional desc string is written as a block doc comment, which either must
 *      precede the param tag, or must start on the same line as the end of the '@inject' tag.
 *    + Examples:
 *    {@inject foo: bool}
 *    {@inject foo: list<int>}  /** A list of numbers. *&#47;
 *    {@inject? foo:
 *        list<int>}  /**
 *        A list of numbers. *&#47;
 *
 * Body:
 *
 * 1. Soy tag format:
 *    + Can be delimited by single braces "{...}".
 *    + } characters are only allowed in tags if they're inside string literals.
 *    + Some Soy tags are allowed to end in "/}" to denote immediate ending of a block.
 *    + It is an error to use "/}" when it's not applicable to the command.
 *    + If there is a command name, it must come immediately after the opening delimiter.
 *    + The command name must be followed by either the closing delimiter (if the command does not
 *      take any command text) or a whitespace (if the command takes command text).
 *    + It is an error to provide command text when it's not applicable, and vice versa.
 *    + This parser does not parse command text (that will be separate).
 *    Examples:
 *    {print $boo}   // explicit 'print' command
 *    {$boo.foo}   // implicit 'print' command
 *    {printer}   // implicit 'print' command (the prefix 'print' here is not a command name)
 *    {\n}   // a command that doesn't take any command text
 *    {call .gooMoo data="all" /}   // self-ending block
 *    {call .gooMoo data="all"}...{/call}   // block with separate start and end tags
 *
 * 2. Raw text:
 *    + Raw text is fixed text that will be part of the template output. There are 3 types.
 *    + Any text outside of Soy tags is raw text.
 *    + There are 7 special character commands that produce raw text strings:
 *      {sp} = space   {nil} = empty string   {\n} = newline (line feed)   {\r} = carriage return
 *      {\t} = tab   {lb} = left brace   {rb} = right brace
 *    + A section of raw text (may contain braces) can be enclosed within a 'literal' block:
 *      {literal}...{/literal}
 *
 * 3. Msg blocks:
 *    + A block between 'msg' and '/msg' tags represents a message for translation.
 *    + It is an error to nest 'msg' blocks.
 *    + Within a 'msg' block, the parsing of Soy tags is the same. The only difference is that we
 *      also recognize "&lt;" and "&gt;" as opening and closing an HTML tag. This is because each
 *      HTML tag as a whole needs to be turned into a single placeholder in the message.
 *    + A 'msg' block may have a 'plural' or 'select' block as its only content.
 *    + A 'msg' block may be followed by optional additional 'fallbackmsg' blocks.
 *    Example:
 *    {msg desc="Event title."}
 *      Join event &lt;a href="{$event.url}"&gt;{$event.title}&lt;/a&gt;.
 *    {fallbackmsg desc="Event title."}
 *      Join event {$event.title}.
 *    {/msg}
 *
 * 4. Other Soy commands:
 *    {print ...}
 *    {...}    // implied 'print' command
 *    {xid ...}
 *    {css ...}
 *    {let ... /}
 *    {let ...}...{/let}
 *    {if ...}...{elseif ...}...{else ...}...{/if}
 *    {switch ...}{case ...}...{default}...{/switch}
 *    {foreach ...}...{ifempty}...{/foreach}
 *    {for ...}...{/for}
 *    {call ... /}
 *    {delcall ... /}
 *    {call ...}{param ... /}{param ...}...{/param}{/call}
 *    {delcall ...}{param ... /}{param ...}...{/param}{/delcall}
 *    {log}...{/log}
 *    {debugger}
 *
 * 5. Misc:
 *    + The following commands are not allowed to appear in a template:
 *      {namespace ...}   {template ...}   {/template}
 * </pre>
 *
 * <p>TODO(lukes):  This parser has a lot of issues:
 * Too much parsing logic is handled by the AST nodes with regular expressions.  This is probably
 * slower than handling it in the parser and it leads to redundant error handling code.
 *
 */
public class SoyFileParser {
  /** Regex string used in patterns below. Note the first set of spaces is reluctant. */
  private static final String LINE_BOUNDARY_REGEX = "\\s*?(\\n|\\r)\\s*";

  /** Pattern for a line boundary. */
  private static final Pattern LINE_BOUNDARY_PATTERN = Pattern.compile(LINE_BOUNDARY_REGEX);

  static class RegexFromTokenImageFunction implements Function<String, String> {
    @Override public String apply(String o) {
      // Strip the surrounding quotes and braces.
      return Pattern.quote(o.substring(2, o.length() - 2));
    }
  };
  /** Pattern for invalid implicit print prefixes (used to throw errors for invalid commands). */
  private static final Pattern INVALID_PRINT_PREFIX_PATTERN = Pattern.compile(
      // tokenImage contains token names for error messages. For literal tokens, it stores the token
      // value as-is, wrapped in quotes. Use this to extract simple token names without duplication.
      "^(" + Joiner.on("|").join(FluentIterable.from(Arrays.asList(tokenImage))
              .filter(Predicates.containsPattern("^\"\\{[a-z]+\\}\"$"))
              .transform(new RegexFromTokenImageFunction()))
      + ")\\b.+");

  /** Pattern for invalid implicit print prefixes (used to throw errors for invalid commands). */
  private static final Pattern INVALID_PRINT_FILE_PREFIX_PATTERN = Pattern.compile(
      "^(namespace|(del)?template|typedef|alias)\\b.*");

  private static final Joiner NO_SEP_JOINER = Joiner.on("");

  // Template errors:
  private static final SoyErrorKind UNEXPECTED_CLOSING_TAG =
      SoyErrorKind.of("Unexpected closing tag ''{0}''.");

  private static final SoyErrorKind FOUND_DOUBLE_BRACE =
      SoyErrorKind.of("Soy '{{command}}' syntax is no longer supported.  Use single braces.");

  private static final SoyErrorKind INVALID_DECLARATION =
      SoyErrorKind.of("Invalid declaration ''{0}''.");

  private static final SoyErrorKind INVALID_PRINT_PREFIX =
      SoyErrorKind.of("Command ''{0}'' cannot have arguments.");

  private static final SoyErrorKind INVALID_PRINT_FILE_COMMAND =
      SoyErrorKind.of("Command ''{0}'' cannot appear in templates.");

  private static final SoyErrorKind PLURAL_AND_SELECT_NOT_ALLOWED_INSIDE_PLURAL_BLOCK =
      SoyErrorKind.of("Tags ''plural'' and ''select'' are not allowed inside ''plural'' blocks.");

  private static final SoyErrorKind MULTIPLE_PHNAME_ATTRIBUTES_IN_COMMAND = SoyErrorKind.of(
      "Found multiple ''phname'' attributes in command text \"{0}\".");

  private static final SoyErrorKind PRINT_COMMAND_WITH_EMPTY_TEXT =
      SoyErrorKind.of("Found ''print'' command with empty command text.");

  private static final SoyErrorKind INVALID_PRINT_COMMAND_TEXT =
      SoyErrorKind.of("Invalid ''print'' command text \"{0}\" (check the directives).");

  private static final SoyErrorKind UNEXPECTED_CONTENT_BEFORE =
      SoyErrorKind.of("Unexpected content before ''{0}'', expected only comments or whitespace.");
  private static final SoyErrorKind UNEXPECTED_CONTENT_AFTER =
      SoyErrorKind.of("Unexpected content after ''{0}'', expected only comments or whitespace.");

  /** Type registry for resolving type names. */
  private SoyTypeRegistry typeRegistry;

  /** Node id generator for the tree being built. */
  private IdGenerator nodeIdGen;

  /** The kind of this Soy file. */
  private SoyFileKind soyFileKind;

  /** Path of source being parsed. This is descriptive, not a means to refetch source. */
  private String filePath;

  private ErrorReporter errorReporter;

  /** Can only be used in templates. */
  private SoyParsingContext context;

  /**
   * Constructor that takes a reader object providing the input.
   * @param typeRegistry The type registry for resolving type names.
   * @param nodeIdGen The node id generator for the tree being built.
   * @param input The input to parse.
   * @param soyFileKind The kind of this Soy file.
   * @param filePath The path of the source being parsed. Used for reporting.
   * @param errorReporter For reporting parse errors.
   */
  public SoyFileParser(
      SoyTypeRegistry typeRegistry,
      IdGenerator nodeIdGen,
      Reader input,
      SoyFileKind soyFileKind,
      String filePath,
      ErrorReporter errorReporter) {
    this(input);
    Preconditions.checkNotNull(typeRegistry);
    Preconditions.checkNotNull(nodeIdGen);
    this.typeRegistry = typeRegistry;
    this.nodeIdGen = nodeIdGen;
    this.soyFileKind = soyFileKind;
    this.filePath = filePath;
    this.errorReporter = errorReporter;
  }

  /**
   * Attempts to parse the given input as a Soy file, returns null if parsing fails.
   */
  public SoyFileNode parseSoyFile() {
    Preconditions.checkNotNull(typeRegistry);
    Preconditions.checkNotNull(nodeIdGen);
    Checkpoint checkpoint = errorReporter.checkpoint();
    SoyFileNode soyFileNode = null;
    try {
      soyFileNode = SoyFile();
    } catch (ParseException e) {
      ParseErrors.reportSoyFileParseException(errorReporter, filePath, e);
    } catch (LegacyInternalSyntaxException e) {
      ParseErrors.report(errorReporter, filePath, e);
    } catch (TokenMgrError e) {
      ParseErrors.reportTokenMgrError(errorReporter, filePath, e);
    }
    // our callers expect us to return null when encountering parsing errors.
    if (errorReporter.errorsSince(checkpoint)) {
      return null;
    }
    return soyFileNode;
  }

  private <T> SourceItemInfo<T> newSourceItemInfo(T parsed, Token token) {
    return newSourceItemInfo(
        parsed, token.beginLine, token.beginColumn, token.endLine, token.endColumn);
  }
  private <T> SourceItemInfo<T> newSourceItemInfo(T parsed, Token begin, Token end) {
    return newSourceItemInfo(
        parsed, begin.beginLine, begin.beginColumn, end.endLine, end.endColumn);
  }

  private <T> SourceItemInfo<T> newSourceItemInfo(T parsed, SourceItemInfo<?> begin,
      SourceItemInfo<?> end) {
    return new SourceItemInfo<T>(parsed, begin, end);
  }

  private <T> SourceItemInfo<T> newSourceItemInfo(
      T parsed, int lineNum, int columnNum, int lineNumEnd, int columnNumEnd) {
    return new SourceItemInfo<T>(filePath, parsed,
        lineNum, columnNum,
        lineNumEnd, columnNumEnd);
  }

  private <T> SourceItemInfo<T> newSourceItemInfo(
      T parsed, SourceLocation location) {
    return new SourceItemInfo<T>(parsed, location);
  }

  private <T> SourceItemInfo<T> newSourceItemInfo(
      T parsed, SourceLocation begin, SourceLocation end) {
    return new SourceItemInfo<T>(parsed, begin.extend(end));
  }

  private SourceLocation createSrcLoc(Token tok1, Token ...rest) {
    return Tokens.createSrcLoc(filePath, tok1, rest);
  }

  // Methods for managing lexical states from the parser
  // Be careful using these.  You should only use them at fixed points where you know.
  // * The lexer is only one token ahead (and you generally know the exact token)
  // * The state change isn't possible to perform from the lexer directly. For example, because it
  //   depends on a 'syntactic element' such as a tag attribute (e.g. kind="html")
  // * There is a clear matching syntactic element for exiting the state (e.g. a close tag)


  /** Switch the parser to a new state and push the current state onto the stack. */
  private void pushState(int nextState) {
    Tokens.checkLexerIsExactlyOneTokenAhead(this);
    token_source.pushState(nextState);
  }

  /** pop the stack and switch to that state. */
  private void popState() {
    Tokens.checkLexerIsExactlyOneTokenAhead(this);
    token_source.popState();
  }

  private void popStateIfStateIs(int state) {
    Tokens.checkLexerIsExactlyOneTokenAhead(this);
    token_source.popStateIfStateIs(state);
  }

  // An error that can be thrown to abort parsing.  This is useful if an error has been reported
  // and it is known that parsing cannot continue.
  private static final class AbortParsingError extends Error {}
}

PARSER_END(SoyFileParser)


// =================================================================================================
// Tokens
// =================================================================================================


TOKEN_MGR_DECLS:
{
  // Template parser:

  // Used for returning to our prior lexical state when completing a multiline comment.
  private final LexicalStateStack stateStack = new LexicalStateStack();


  /** Saves the current lexical state and switch to a new one.  To switch back call
   * {@link #popState()}.
   */
  void pushState(int newState) {
    stateStack.push(curLexState);
    SwitchTo(newState);
  }

 /**
  * Switch back to the previous state stored in {@link #stateStack}.
  */
  void popState() {
    SwitchTo(stateStack.pop());
  }

  /**
   * Conditionally pops the given state if it is at the top of the stack and the stack isn't empty.
   *
   * <p>Most users should use {@link #popState()} but in error conditions this can be useful to
   * prevent underflowing the stack.
   */
  void popStateIfStateIs(int state) {
    if (stateStack.peek() == state) {
      popState();
    }
  }

  private void clearAndSwitchToDefault() {
    stateStack.clear();
    SwitchTo(DEFAULT);
  }
}

// Tips on writing a good lexer
// https://javacc.java.net/doc/lexertips.html

// =================================================================================================
// File (non-template) tokens
// =================================================================================================

// In default (outside of templates) structured tags and expressions, skip whitespace and line
// comments
// NOTE: the TEMPLATE_* states can't be specified here because it would interfere with the
// interpretation of url schemes in 'raw text' e.g. http://foo.com  So those lexical states use a
// different set of tokens.
<DEFAULT, IN_CMD_TAG_STRUCTURED, EXPR> SKIP: {
  < <WS> >
|  < <LINE_COMMENT> >
}

// In all these states, SKIP multiline comments
// NOTE: we don't just configure this for state * because these comments shouldn't work in things
// like string literals or attribute values
<DEFAULT, IN_CMD_TAG_STRUCTURED, EXPR, TEMPLATE_DEFAULT, TEMPLATE_DEFAULT_IN_MSG_BLOCK> MORE: {
  <"/*"> { pushState(IN_MULTILINE_COMMENT); }
}

<IN_MULTILINE_COMMENT, IN_SOYDOC> MORE : {
  < ~[] >
}

<IN_MULTILINE_COMMENT> SKIP : {
  <"*/"> { popState(); }
}

// SOYDOC
// Capture all soydoc into a SPECIAL_TOKEN.
// SPECIAL_TOKEN (http://www.engr.mun.ca/~theo/JavaCC-FAQ/javacc-faq-moz.htm#tth_sEc3.10)
// is a special javacc mechanism whereby we can create a 'token' that isn't directly passed to the
// parser. Normally, the stream of text gets turned into a stream of 'tokens' that then get matched
// by the parser.  A SPECIAL_TOKEN is just like a normal token, except it is not directly passed to
// the parser.  Instead, SPECIAL_TOKENs can be accessed via the normal tokens that immediately
// follow them via the Token.specialToken field.
// This behavior is useful for matching SoyDoc since we are really only interested in soydoc that
// immediately precedes template definitions.  We could theoretically handle this by creating non
// terminal for matching soydoc and then writing a BNF expression for it.  However, then we would
// have to write BNF expressions to match (and ignore) soydoc in all other contexts, which would be
// tedious.

// NOTE: we don't use all the same states as normal multiline comments (see above), this is because
// the distinction between 'doc comments' and 'multiline comments' is only relevant in these states.
<DEFAULT, TEMPLATE_DEFAULT, TEMPLATE_DEFAULT_IN_MSG_BLOCK> MORE : {
   "/**" { pushState(IN_SOYDOC); }
}

<IN_SOYDOC> SPECIAL_TOKEN : {
  <SOYDOC: "*/" > { popState(); }
}

<DEFAULT> TOKEN : {
  <ALIAS_OPEN: "{alias"> { pushState(IN_CMD_TAG_STRUCTURED); }
| <NAMESPACE_OPEN: "{namespace"> { pushState(IN_CMD_TAG_STRUCTURED); }
| <DELPACKAGE_OPEN: "{delpackage"> { pushState(IN_CMD_TAG_STRUCTURED); }
}

<IN_CMD_TAG_STRUCTURED> MORE: {
  "\"" : IN_ATTRIBUTE_VALUE
}

<IN_ATTRIBUTE_VALUE> TOKEN: {
  <ATTRIBUTE_VALUE: "\""> : IN_CMD_TAG_STRUCTURED
}

// In attribute values accumulate all non-double quote characters unless they are escaped.  N.B.
// This includes newlines which is important for backwards compatibility.
<IN_ATTRIBUTE_VALUE> MORE: {
 <~[]>
| "\\\""
}

// Templates

<DEFAULT> TOKEN : {
  <DELTEMPLATE_OPEN : "{deltemplate" > { pushState(IN_CMD_TAG_STRUCTURED); }
| <TEMPLATE_OPEN: "{template" > { pushState(IN_CMD_TAG_STRUCTURED); }
}



// =================================================================================================
// Template tokens (only used inside templates)
// =================================================================================================

// -------------------------------------------------------------------------------------------------
// Line comment.

// Due to ambiguity with uri schemes, line comments in TEMPLATE_DEFAULT and
// TEMPLATE_DEFAULT_IN_MSG_BLOCK are only interpreted as such if there is preceding whitespace.
// Other lexical states don't have this requirement.  The fact that comments swallow a leading
// whitespace character doesn't affect output because of how line joining works.
<TEMPLATE_DEFAULT, TEMPLATE_DEFAULT_IN_MSG_BLOCK> SKIP:
{
  < <WS> <LINE_COMMENT> >
}


// -------------------------------------------------------------------------------------------------
// Soy commands.

// ------------ Step 1: Match an opening tag (or full self-closing tag) ------------
// Prefixes:
//  - FULL for self-closing tags (return to default state after token, with no context for tag)
//  - OPEN for complete opening tags (switch to content or default state, but expect closing tag)
//  - BEGIN for incomplete opening tags (switch to IN_CMD_TAG to expect command parameters)
//  - CLOSE for closing tags (return to default state)
// OPEN tags must include trailing whitespace, to prevent them from matching implicit print commands
// which begin with the same characters (eg, `{format(blah)}`).

// IN_CMD_TAG_STRUCTURED is used for commands that parse their command text in the tokenizer. It has
// tokens for each valid construct that can appear in these tags.
//
// In the long run, all commands should have structured parsing, for now it is only {@param} and
// {@inject}
//
// IN_CMD_TAG_UNSTRUCTURED is for older or more-complex tags that are parsed through regexes, or the
// expression parser.  It swallows any kind of token into CMD_TEXT_ARBITRARY_TOKEN.

<TEMPLATE_DEFAULT, TEMPLATE_DEFAULT_IN_MSG_BLOCK> TOKEN:
{
  <CMD_CLOSE_TEMPLATE            : "{/template}"> { clearAndSwitchToDefault(); }
| <CMD_CLOSE_DELTEMPLATE         : "{/deltemplate}"> { clearAndSwitchToDefault(); }

| < DECL_BEGIN_PARAM             : "{@param"    >  { pushState(IN_CMD_TAG_STRUCTURED); }
| < DECL_BEGIN_OPT_PARAM         : "{@param?"   >  { pushState(IN_CMD_TAG_STRUCTURED); }
| < DECL_BEGIN_INJECT_PARAM      : "{@inject"   >  { pushState(IN_CMD_TAG_STRUCTURED); }
| < DECL_BEGIN_OPT_INJECT_PARAM  : "{@inject?"  >  { pushState(IN_CMD_TAG_STRUCTURED); }

| < XXX_BRACE_INVALID            : "}" >
| < CMD_FULL_SP                  : "{sp}"       >
| < CMD_FULL_NIL                 : "{nil}"      >
| < CMD_FULL_LF                  : "{\\n}"      >
| < CMD_FULL_CR                  : "{\\r}"      >
| < CMD_FULL_TAB                 : "{\\t}"      >
| < CMD_FULL_LB                  : "{lb}"       >
| < CMD_FULL_RB                  : "{rb}"       >

| < CMD_OPEN_LITERAL             : "{literal}"  >  { pushState(IN_LITERAL_BLOCK); }

| < CMD_BEGIN_CALL               : "{call" <WS>    > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_BEGIN_DELCALL            : "{delcall" <WS> > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_CLOSE_CALL               : "{/call}"       >
| < CMD_CLOSE_DELCALL            : "{/delcall}"    >

| < CMD_BEGIN_PARAM              : "{param" <WS>     > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_CLOSE_PARAM              : "{/param}"   >

| < CMD_BEGIN_MSG                : "{msg" <WS>  > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_BEGIN_FALLBACK_MSG  : "{fallbackmsg" <WS> > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_CLOSE_MSG           : "{/msg}"     >

| < CMD_BEGIN_PRINT              : "{print" <WS>   > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_BEGIN_XID                : "{xid" <WS>    > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_BEGIN_CSS                : "{css" <WS>    > { pushState(IN_CMD_TAG_UNSTRUCTURED); }

| < CMD_BEGIN_IF                 : "{if" <WS>     > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_BEGIN_ELSEIF             : "{elseif" <WS> > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_FULL_ELSE                : "{else}"       >
| < CMD_CLOSE_IF                 : "{/if}"        >

| < CMD_BEGIN_LET                : "{let" <WS>    > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_CLOSE_LET                : "{/let}"       >

| < CMD_BEGIN_FOR                : "{for" <WS>    > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_CLOSE_FOR                : "{/for}"       >

| < CMD_BEGIN_PLURAL             : "{plural" <WS> > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_CLOSE_PLURAL             : "{/plural}"    >

| < CMD_BEGIN_SELECT             : "{select" <WS> > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_CLOSE_SELECT             : "{/select}"    >

| < CMD_BEGIN_SWITCH             : "{switch" <WS> > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_CLOSE_SWITCH             : "{/switch}"    >

| < CMD_FULL_DEFAULT             : "{default}"    >
| < CMD_BEGIN_CASE               : "{case" <WS>   > { pushState(IN_CMD_TAG_UNSTRUCTURED); }

| < CMD_BEGIN_FOREACH            : "{foreach" <WS>> { pushState(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_FULL_IFEMPTY             : "{ifempty}"  >
| < CMD_CLOSE_FOREACH            : "{/foreach}" >

| < CMD_OPEN_LOG                 : "{log}"      >
| < CMD_CLOSE_LOG                : "{/log}"     >
| < CMD_FULL_DEBUGGER            : "{debugger}" >
| < CMD_BEGIN_IMPLICIT_PRINT     : "{"          > { pushState(IN_CMD_TAG_UNSTRUCTURED); }
}


// ------------ Step 2: Match the command text and closing delimiter ------------

<IN_CMD_TAG_UNSTRUCTURED, IN_CMD_TAG_STRUCTURED, EXPR> TOKEN: {
  < CMD_END : "}" > { popState(); }
| < CMD_SELF_CLOSE : "/}" > { popState(); }
}

<IN_CMD_TAG_UNSTRUCTURED> TOKEN: {
 < CMD_TEXT_DIRECTIVE_NAME: "|" <IDENT> >
// TODO(lukes): Once we merge in the ExpressionParser, use CommandTagAttribute () instead.
| < CMD_TEXT_PHNAME_ATTR: <WS_CHAR> "phname=\"" <IDENT> "\"" >
| < XXX_CMD_TEXT_PHNAME_NOT_IDENT: <WS_CHAR> "phname=\"" ( ~["\""] )* "\"" >
}


<IN_CMD_TAG_STRUCTURED> TOKEN: {
  // This is for {@param foo : int} and (eventually) {let $foo : someExpression()}.  A colon in a
  // structured tag transitions us into the EXPR state.
  < TAG_COLON : ":"  >: EXPR
| <EQ : "=">
| <AS: "as">
}

<IN_CMD_TAG_STRUCTURED, EXPR> TOKEN: {
  // This makes NAME a matchable token within structured tags and exprs (IDENT is otherwise private)
  < NAME : <IDENT> >
| < DOT: "." >
}

// EXPR is for type expressions and (eventually) soy expressions

<EXPR> TOKEN: {
   < LANGLE: "<" >
 | < RANGLE: ">" >
 | < LBRACKET: "[" >
 | < RBRACKET: "]" >
 | < COMMA: "," >
 | < COLON : ":"  >
  // NOTE: this means that "|" <IDENT> is a valid matchable token sequence. But for print
  // directives we have "|"<IDENT> as a single token.  This is bad since any|null will get
  // tokenized as <IDENT> <CMD_TEXT_DIRECTIVE_NAME> instead of <IDENT> <VBAR> <IDENT>.  The
  // reason this isn't currently a problem is because CMD_TEXT_DIRECTIVE_NAME is defined in a
  // different lexical state.  This will become a problem when we switch print node to use
  // structured tag parsing.
 | < VBAR: "|" >
 | < QMARK: "?" >
}

<IN_CMD_TAG_UNSTRUCTURED> TOKEN: {
  // Allow any non-string token, or complete quoted string literals.
  < CMD_TEXT_ARBITRARY_TOKEN:
      ~["'", "\"", "}"]
    // | ("/" ~["}"])  // Allow /, but not /} (so we don't swallow self-closing tags)
    | "\""
      (
          ~["\"","\\"]
        | "\\" ~[]
      )*
      "\""
    // Must match <STRING> in ExpressionParser.jj, but allow newlines and lowercase hex literals
    // (for legacy templates).
    | "'"
      (
          ~["'","\\"]
        | "\\" ["n","r","t","b","f","\\","'","\""]
        | "\\u" (["0"-"9","A"-"F", "a"-"f"]){4}
      )*
      "'"
  >
  // Force friendly error messages by providing a token to match error cases.
| <XXX_INVALID_STRING_LITERAL: ["'", "\""]>
}


// -------------------------------------------------------------------------------------------------
// In a 'msg' block.

// The only difference between states TEMPLATE_DEFAULT and
// TEMPLATE_DEFAULT_IN_MSG_BLOCK is that the latter also create tokens for HTML tag open/close.
<TEMPLATE_DEFAULT_IN_MSG_BLOCK> TOKEN:
{
  < MSG_HTML_TAG_OPEN:  "<" >
|
  < MSG_HTML_TAG_CLOSE: ">" >
}


// -------------------------------------------------------------------------------------------------
// In a 'literal' block.

// Collect the literal text using MORE.
<IN_LITERAL_BLOCK> MORE:
{
  < <ANY_CHAR> >
}

// When we reach the '/literal' tag, return the collected text content (minus the end tag).
<IN_LITERAL_BLOCK> TOKEN:
{
  < LITERAL_RAW_TEXT_CONTENT: "{/literal}" >
  {
    // Note: 'image' is cumulative over MOREs while 'lengthOfMatch' is just the end tag length.
    matchedToken.image = image.substring(0, image.length() - lengthOfMatch);
    popState();
  }
}

// -------------------------------------------------------------------------------------------------
// Text.

<TEMPLATE_DEFAULT, TEMPLATE_DEFAULT_IN_MSG_BLOCK> TOKEN:
{
  < TOKEN_WS: <WS> >
|
  < TOKEN_NOT_WS: <NOT_WS> >
}

// Private helper regexes.
<*> TOKEN:
{
  < #ANY_CHAR: ~[] >
|
  < #WS: " " | "\t" | "\n" | "\r" | "\r\n" >
|
  < #WS_CHAR: " " | "\t" | "\n" | "\r" >
|
  < #NOT_WS: ~[" ","\t","\n","\r"] >
|
  < #NOT_NL: ~["\n","\r"] >
|
  < #BRACE: ["{","}"] >
|
  < #IDENT: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","_","0"-"9"] )* >
|
  < #LINE_COMMENT: "//" ( <NOT_NL> )* >
}

// Match everything else as an 'unexpected' token to prevent TokenMgrErrors from being thrown and
// instead this will get turned into ParseExceptions which have more debugging information.
// NOTE: this has to come after any single character token definition in these states.
// TODO(slaks): Apply to all states.
<DEFAULT, IN_CMD_TAG_STRUCTURED, EXPR> TOKEN : {
    < UNEXPECTED_TOKEN : ~[] >
}

// =================================================================================================
// Grammar
// =================================================================================================


/**
 * Matches the whole input if it is a valid Soy file.
 *
 * SoyFile -> [ DelpackageTag ] [ NamespaceTag ] ( AliasTag )* ( Template )* EOF
 */
private SoyFileNode SoyFile() :
{
  TemplateNode template;
  NamespaceDeclaration namespace;
  Identifier delpackageName = null;
  List<AliasDeclaration> aliases = ImmutableList.of();
  AliasDeclaration alias = null;
}
{
  [ delpackageName = DelPackage() ]

  namespace = Namespace()

  (
    alias = Alias()
    { if (aliases.isEmpty()) {
       aliases = new ArrayList<AliasDeclaration>();
     }
     aliases.add(alias);
    }
  )*

  {
    SoyFileHeaderInfo soyFileHeaderInfo = new SoyFileHeaderInfo(errorReporter,
      delpackageName, namespace, aliases);
    context = SoyParsingContext.create(errorReporter, soyFileHeaderInfo.namespace,
        soyFileHeaderInfo.aliasToNamespaceMap);
    SoyFileNode sfn =
        new SoyFileNode(
            nodeIdGen.genId(),
            filePath,
            soyFileKind,
            namespace,
            soyFileHeaderInfo);
  }

  (
    template = Template(soyFileHeaderInfo)
    { if (template != null) {
       // it will be null if a parsing error occurred
       sfn.addChild(template);
     }
    }
  )+

  <EOF>

  { return sfn; }
}

/**
 * Matches an {alias ...} declaration.
 */
private AliasDeclaration Alias() :
{
  Token open, close;
  Identifier namespace, alias = null;
  Token as = null;
}
{
  (
    open = <ALIAS_OPEN>
    namespace = DottedIdent()
    [
      as = <AS>
      alias = DottedIdent()
    ]
    close = <CMD_END>
  )
  {
    return alias == null
        ? new AliasDeclaration(
            namespace.identifier(),
            errorReporter,
            createSrcLoc(open, close))
        : new AliasDeclaration(
            namespace.identifier(),
            alias.identifier(),
            errorReporter,
            createSrcLoc(open, close));
  }
}

/**
 * Matches a {namespace ...} declaration.
 */
private NamespaceDeclaration Namespace() :
{
  Token open, close;
  Identifier name;
  CommandTagAttribute attr;
  List<CommandTagAttribute> attributes;
}
{
  open = <NAMESPACE_OPEN>
  name = DottedIdent()
  attributes = CommandAttributes()
  close = <CMD_END>
  {
    return new NamespaceDeclaration(name, attributes, errorReporter);
  }
}

/**
 * Matches an arbitrary sequence of CommandAttributes()
 */
private List<CommandTagAttribute> CommandAttributes() :
{
  CommandTagAttribute attr;
  List<CommandTagAttribute> attributes = ImmutableList.of();
}
{
   (
    attr = Attribute()
    { if (attributes.isEmpty()) {
        attributes = new ArrayList<CommandTagAttribute>();
      }
      attributes.add(attr);
    }
  )*

  // None of our commands ever allow attributes to be duplicated.
  // Drop duplicates and report errors before returning to our caller.
  { CommandTagAttribute.removeDuplicatesAndReportErrors(attributes, errorReporter);
    return attributes;
  }
}


/**
 * Matches a name value pair.
 *
 * Attribute -> <NAME> <EQ> <ATTRIBUTE_VALUE>
 */
private CommandTagAttribute Attribute() :
{
  Token name;
  Token eq;
  Token value;
}
{
  name = <NAME>
  eq = <EQ>
  value = <ATTRIBUTE_VALUE>
  {
    return new CommandTagAttribute(
        Identifier.create(name.image, createSrcLoc(name)),
        // trim quotes off the token and unescape internal quotation marks
        value.image.substring(1, value.image.length() - 1).replace("\\\"", "\""),
        createSrcLoc(value));
  }
}

/**
 * Matches a {delpackage ...} declaration.
 */
private Identifier DelPackage() :
{
  Identifier name;
}
{
  <DELPACKAGE_OPEN>
  name = DottedIdent()
  <CMD_END>
  {
    return name;
  }
}


/**
 * Template -> (
 *   <TEMPLATE_OPEN>
 *   TemplateName()
 *   CommandAttributes()
 *   <CMD_END>
 *   TemplateHeader()
 *   TemplateBlock()
 *   <CMD_CLOSE_TEMPLATE>
 * |
 *   <DELTEMPLATE_OPEN>
 *   TemplateName()
 *   CommandAttributes()
 *   <CMD_END>
 *   TemplateHeader()
 *   TemplateBlock()
 *   <CMD_CLOSE_DELTEMPLATE>
 * )
 *
 * @param soyFileHeaderInfo Info from the containing Soy file's header declarations. Needed by the
 *     TemplateNode constructors.
 */
private TemplateNode Template(SoyFileHeaderInfo soyFileHeaderInfo) :
{
  Token open;
  TemplateNode templateNode = null;
  TemplateNodeBuilder builder;
}
{
  (
    open = <TEMPLATE_OPEN>
    { builder = new TemplateBasicNodeBuilder(soyFileHeaderInfo, errorReporter); }
    try {
      templateNode = TemplateHelper(builder, open)
      <CMD_CLOSE_TEMPLATE>
    } catch (ParseException e) {
      reportErrorAndSkipTo(e, CMD_CLOSE_TEMPLATE);
    } catch (AbortParsingError e) {
      // do nothing, continue trying to parse other templates
      return null;
    }

  | open = <DELTEMPLATE_OPEN>
    { builder = new TemplateDelegateNodeBuilder(soyFileHeaderInfo, errorReporter); }
    try {
      templateNode = TemplateHelper(builder, open)
      <CMD_CLOSE_DELTEMPLATE>
    } catch (ParseException e) {
      reportErrorAndSkipTo(e, CMD_CLOSE_DELTEMPLATE);
    } catch (AbortParsingError e) {
      // do nothing, continue trying to parse other templates
      return null;
    }
  )
  { return templateNode; }
}

/**
 * A helper for parsing everything except the open and close tags of a template.
 */
private TemplateNode TemplateHelper(TemplateNodeBuilder builder, Token open) :
{
  Token close;
  List<StandaloneNode> templateBodyNodes;
  RawTextNode initialRawText;
  Identifier templateName;
  List<CommandTagAttribute> attributes;
}
{
  {
    // eagerly fetch the id to be backwards compatible.  if we delay allocating, all the ids in the
    // file will change.  TODO(user): remove ids
    builder.setId(nodeIdGen.genId());
  }
  templateName = TemplateName()
  attributes = CommandAttributes()
  {
    builder.setCommandValues(templateName, attributes);
    // We can't set soy doc until after setCommandValues due to conditions in the builder.
    // --- Set the SoyDoc. ---
    // special tokens are accessible from the non-special tokens that come after them.
    Token soyDoc = open.specialToken;
    if (soyDoc != null && soyDoc.kind == SOYDOC) {
      builder.setSoyDoc(soyDoc.image, createSrcLoc(soyDoc));
    }
    pushState(TEMPLATE_DEFAULT);
  }
  close = <CMD_END>
  { builder.setSourceLocation(createSrcLoc(open, close)); }
  initialRawText = TemplateHeader(builder)
  templateBodyNodes = TemplateBlock()
  {
    TemplateNode templateNode = builder.build();
    if (initialRawText != null) {
      templateNode.addChild(initialRawText);
    }
    templateNode.addChildren(templateBodyNodes);
    return templateNode;
  }
}

// TODO(mknichel): Since all Soy files have namespaces, we can split the parsing so that {template
// tags can only allow <DOT><NAME> and TemplatedelegateName only allows DottedIdent()
/**
 * Parses a Template name.  This is either a fully qualified dotted identifier or a partial
 * identifier consisting of a single <DOT><IDENT> sequence.
 *
 * TemplateName -> (<DOT> <NAME> | DottedIdent() )
 */
private Identifier TemplateName():
{
  Token dot, name;
  Identifier ident;
}
{
  (
    // The partial name case.
    dot = <DOT>
    name = <NAME>
    { ident= Identifier.create("." + name.image, createSrcLoc(dot, name)); }
  |
    ident = DottedIdent()
  )
  { return ident; }
}

/**
 * DottedIdent -> <NAME> (<DOT> <NAME>)*
 */
private Identifier DottedIdent():
{
  StringBuilder sb = null;
  Token dot, name, next = null;
}
{
  name = <NAME>
  (
    dot = <DOT>
    next = <NAME>
    { if (sb == null) {
        sb = new StringBuilder();
        sb.append(name.image);
      }
      sb.append('.').append(next.image);
    }
  )*
  {
    return sb == null
      ? Identifier.create(name.image, createSrcLoc(name))
      : Identifier.create(sb.toString(), createSrcLoc(name, next));
  }
}

JAVACODE
/**
 * Reports the error and skips to the given token.
 *
 * See https://javacc.java.net/doc/errorrecovery.html
 */
private Token reportErrorAndSkipTo(ParseException error, int kind) {
  ParseErrors.reportSoyFileParseException(errorReporter, filePath, error);
  Token t;
  do {
    t = getNextToken();
  // We need to halt when observing EOF.  The behavior of the token manager is to keep returning
  // EOF from getNextToken(), so if we don't check for it this will become an infinite loop.
  } while (t.kind != kind && t.kind != EOF);
  return t;
}

JAVACODE
/**
 * Reports the error and skips to the given token if it observes the end of a template, throws an
 * exception to halt parsing.
 *
 * See https://javacc.java.net/doc/errorrecovery.html
 */
private Token reportTemplateBodyErrorAndSkipTo(ParseException error, int kind) {
  ParseErrors.reportSoyFileParseException(errorReporter, filePath, error);
  Token t;
  do {
    t = getNextToken();
    if (t.kind == CMD_CLOSE_TEMPLATE || t.kind == CMD_CLOSE_DELTEMPLATE) {
      throw new AbortParsingError();
    }
  // We need to halt when observing EOF.  The behavior of the token manager is to keep returning
  // EOF from getNextToken(), so if we don't check for it this will become an infinite loop.
  } while (t.kind != kind && t.kind != EOF);
  return t;
}
// =================================================================================================
// Grammar - Templates
// =================================================================================================


// =================================================================================================
// Grammar basics
// =================================================================================================


// -------------------------------------------------------------------------------------------------
// Soy tag parts.

/**
 * TODO(slaks): Eventually, replace this with tokens for actual command content (eg, attributes).
 * CmdText -> CmdTextParts
 */
private String CmdText():
{
  List<String> cmdTextParts;
}
{
  cmdTextParts = CmdTextParts()
  { return NO_SEP_JOINER.join(cmdTextParts); }
}

/**
 * Same as CmdText() but with source information.
 */
private SourceItemInfo<String> CmdTextWithSource():
{
  SourceItemInfo<List<String>> parts;
}
{
  parts = CmdTextPartsWithSource()
  {
    return newSourceItemInfo(
        NO_SEP_JOINER.join(parts.parsedContent()),
        parts.srcLocation());
  }
}

/**
 * CmdTextParts -> CmdTextPartsWithSource
 */
private List<String> CmdTextParts() :
{
  SourceItemInfo<List<String>> parts;
}
{
  parts = CmdTextPartsWithSource()
  {
    return parts.parsedContent();
  }
}

/**
 * CmdTextPartsWithSource -> ( CmdTextToken | CmdTextDirectiveName | CmdTextPhnameAttr )*
 */
private SourceItemInfo<List<String>> CmdTextPartsWithSource() :
{
  Token first = null;
  Token current = null;
  List<String> cmdTextParts = Lists.newArrayList();
  StringBuilder currCmdTextPartSb = new StringBuilder();
}
{
  (
    (
      current = <CMD_TEXT_ARBITRARY_TOKEN> { currCmdTextPartSb.append(current.image); }
    | (
        current = <CMD_TEXT_DIRECTIVE_NAME>
      | current = <CMD_TEXT_PHNAME_ATTR>
      )
      { // Add the preceding part if nonempty.
        if (currCmdTextPartSb.length() > 0) {
          cmdTextParts.add(currCmdTextPartSb.toString());
          currCmdTextPartSb.setLength(0);
        }
        // Add the special part.
        cmdTextParts.add(current.image);
      }
    )
  { if (first == null) {
      first = current;
    }
  }
  )*

  {
    // Add the last part if nonempty.
    if (currCmdTextPartSb.length() > 0) {
      cmdTextParts.add(currCmdTextPartSb.toString());
      currCmdTextPartSb.setLength(0);
    }

    // Process whitespace.
    // TODO(user): this is the beginning of a code path that should be eliminated.
    // These trimmed command strings are typically passed into Node constructors and then
    // re-passed into the expression parser for further parsing. The trimming and re-parsing
    // makes it hard to reconstruct accurate source location information for expression trees.
    // This file should be the source of truth for all source location information in Soy.
    for (int i = 0, n = cmdTextParts.size(); i < n; i++) {
      String cmdTextPart = cmdTextParts.get(i);
      if (i == 0) {
        cmdTextPart = CharMatcher.whitespace().trimLeadingFrom(cmdTextPart);
      }
      if (i == n - 1) {
        cmdTextPart = CharMatcher.whitespace().trimTrailingFrom(cmdTextPart);
      }
      cmdTextPart = LINE_BOUNDARY_PATTERN.matcher(cmdTextPart).replaceAll(" ");
      cmdTextParts.set(i, cmdTextPart);
    }
    SourceLocation location;
    if (current == null) {
      // use the most recently consumed token for the sourcelocation when the cmd text is empty.
      location = createSrcLoc(getToken(0));
    } else if (current == first) {
      location = createSrcLoc(first);
    } else {
      location = createSrcLoc(first, current);
    }
    return newSourceItemInfo(cmdTextParts, location);
  }
}

// -------------------------------------------------------------------------------------------------
// Raw text.

/**
 * Matches whitespace for the purpose of ignoring it.
 * SkipWhitespace ->  ( <TOKEN_WS> )*
 */
private void SkipWhitespace() : { }
{
  // The LOOKAHEAD here just suppresses a warning, we want the standard greedy behavior.
  ( LOOKAHEAD(1) <TOKEN_WS> )*
}


/**
 * RawTextNode -> ( BasicRawText | LiteralRawText | SpecialCharRawText )+
 *
 * May return null if all content is dropped (due to comments, line joining, etc).
 */
private RawTextNode RawText() :
{
  Token token;
  RawTextBuilder builder = new RawTextBuilder(filePath, nodeIdGen);
}
{
  // There is a choice conflict here because given a sequence of two characters we could parse it
  // as one RawTextNode containing two characters or 2 RawTextNodes each containing one char.
  // However, we always want the former, so we insert this LOOKAHEAD to suppress the
  // conflict warning since the default greedy behavior is what we want.
  ( LOOKAHEAD(1)
    (
      // basic tokens
      (
        token = <TOKEN_NOT_WS>
      | token = <TOKEN_WS>
      )
    { builder.addBasic(token); }
    |
      <CMD_OPEN_LITERAL>
      token = <LITERAL_RAW_TEXT_CONTENT>
    { builder.addLiteral(token); }
    |
      ( token = <CMD_FULL_SP>
      | token = <CMD_FULL_NIL>
      | token = <CMD_FULL_CR>
      | token = <CMD_FULL_LF>
      | token = <CMD_FULL_TAB>
      | token = <CMD_FULL_LB>
      | token = <CMD_FULL_RB>
      )
    { builder.addTextualCommand(token); }
    )
  )+

  { return builder.build(); }
}

// =================================================================================================
// Grammar
// =================================================================================================

// -------------------------------------------------------------------------------------------------
// Template header.

/**
 * Important: The template header consists of a sequence of ParamDecls() separated by optional
 * whitespace
 *
 * TemplateHeader -> ( Whitespace() | ParamDecl() )*
 *
 * Whether or not a particular piece of whitespace is part of the header or part of an initial raw
 * text node is ambiguous.  So if there is a trailing piece of non-trivial whitespace it will be
 * consumed here.  So we return the both
 */
private RawTextNode TemplateHeader(TemplateNodeBuilder templateBuilder) :
{
  HeaderParam param;
  List<HeaderParam> params = ImmutableList.of();
  RawTextNode whitespace = null;
  String soyDoc = null;
}
{
  ( LOOKAHEAD(1)  // prefer consuming whitespace here instead of in a subsequent RawTextNode
    (
    { Token tok;
      RawTextBuilder builder = new RawTextBuilder(filePath, nodeIdGen);
    }
    ( LOOKAHEAD(1)  // prefer staying in the loop
      tok = <TOKEN_WS>
      { if (tok.specialToken != null) {
          soyDoc = tok.specialToken.image;
        }
        builder.addBasic(tok);
      }
    )+
    { whitespace = builder.build(); }
    |
      param = ParamDecl(soyDoc)
      {
        // we just parsed a param, preceding whitespace/doc comments are not important
        whitespace = null;
        soyDoc = null;
        if (params.isEmpty()) {
          params = new ArrayList<HeaderParam>();
        }
        params.add(param);
      }
    )
  )*

  { templateBuilder.addParams(params);
    return whitespace;
  }
}



/**
 * ParamDecl -> SoyTagOpen ( <CMD_NAME_PARAM_DECL> | <CMD_NAME_INJECTED_PARAM_DECL> )
 *              [ <QMARK> ] <WS_AFTER_CMD_NAME> CmdText RegSoyTagClose
 *
 * @param desc The doc comment that was attached to whitespace preceding this param, if any.
 */
private HeaderParam ParamDecl(@Nullable String desc) :
{
  Token ws, tagBegin, name, tagEnd;
  TypeNode paramTypeNode = null;
  SoyType paramType = ErrorType.getInstance();
  String cmdText;
  Token blockDocComment;
  boolean optional = false;
  boolean inject = false;
}
{
  (
    tagBegin = <DECL_BEGIN_PARAM>
  | tagBegin = <DECL_BEGIN_OPT_PARAM>  { optional = true; }
  | tagBegin = <DECL_BEGIN_INJECT_PARAM>  { inject = true; }
  | tagBegin = <DECL_BEGIN_OPT_INJECT_PARAM> { inject = true; optional = true; }
  )
  // If there is a special token directly attached to the {@param, use that instead of whatever
  // was passed to us.
  { if (tagBegin.specialToken != null) {
      desc = tagBegin.specialToken.image;
    }
  }

  name = <NAME>
  <TAG_COLON>
  try {
    paramTypeNode = TypeExpr()
    {
      paramType = typeRegistry.getOrCreateType(paramTypeNode, errorReporter);
    }
    tagEnd = <CMD_END>

  } catch (ParseException parseException) {
    tagEnd = reportTemplateBodyErrorAndSkipTo(parseException, CMD_END);
  }

  {
    if (desc != null) {
      // trim the leading /** and trailing */ as well as the whitespace from the doc comment.
      desc = desc.substring(3, desc.length() - 2).trim();
    }
    return new HeaderParam(
        name.image,
        createSrcLoc(name),
        // Optional params become nullable
        optional ? typeRegistry.getOrCreateUnionType(paramType, NullType.getInstance()) : paramType,
        paramTypeNode,
        // the param is required if it isn't optional and the parsed type isn't nullable.
        !optional && !SoyTypes.isNullable(paramType),
        inject,
        desc);
  }
}

// -------------------------------------------------------------------------------------------------
// Template block.


/**
 * TemplateBlock -> ( RawText | Stmt )*
 */
private List<StandaloneNode> TemplateBlock() :
{
  StandaloneNode node;
}
{
  { List<StandaloneNode> templateBlock = Lists.newArrayList(); }

  (
    (
      node = RawText()
    | node = Stmt()
    )

    { templateBlock.add(node); }
  )*

  { return templateBlock; }
}



// -------------------------------------------------------------------------------------------------
// Soy statements.


/**
 * Stmt ->   MsgStmt | PrintStmt | XidStmt | CssStmt | LetStmt | IfStmt | SwitchStmt
 *         | ForeachStmt | ForStmt| CallStmt | LogStmt | DebuggerStmt
 */
private StatementNode Stmt() :
{
  StatementNode stmt;
}
{
  (
    stmt = NonPrintableStmt()
  | stmt = PrintableStmt()
  | stmt = ControlFlowStmt()
  )

  { return stmt; }
}

/**
 * NonPrintableStmt ->  LetStmt | LogStmt | DebuggerStmt
 */
private StatementNode NonPrintableStmt() :
{
  StatementNode stmt;
}
{
  (
    stmt = LetStmt()
  | stmt = LogStmt()
  | stmt = DebuggerStmt()
  )

  { return stmt; }
}

/**
 * PrintableStmt ->   MsgStmt | PrintStmt | XidStmt | CssStmt | CallStmt
 */
private StatementNode PrintableStmt() :
{
  StatementNode stmt;
}
{
  (
    stmt = MsgStmt()
  | stmt = XidStmt()
  | stmt = CssStmt()
  | stmt = CallStmt()
  | stmt = PrintStmt()
  )

  { return stmt; }
}

/**
 * ControlFlowStmt -> IfStmt | SwitchStmt | ForeachStmt | ForStmt
 */
private StatementNode ControlFlowStmt() :
{
  StatementNode stmt;
}
{
  (
    stmt = IfStmt()
  | stmt = SwitchStmt()
  | stmt = ForeachStmt()
  | stmt = ForStmt()
  )

  { return stmt; }
}


/**
 * MsgStmt -> <CMD_BEGIN_MSG> CmdText <CMD_END> TemplateBlockForMsg
   ( <CMD_BEGIN_FALLBACK_MSG> CmdText <CMD_END> TemplateBlockForMsg )? <CMD_CLOSE_MSG>
 */
private MsgFallbackGroupNode MsgStmt() :
{
  String cmdText;
  List<StandaloneNode> templateBlockForMsg;
  Token tagBegin, tagEnd;
  MsgNode msgNode;
}
{
  tagBegin = <CMD_BEGIN_MSG>
  cmdText = CmdText()
  {
    pushState(TEMPLATE_DEFAULT_IN_MSG_BLOCK);
    Checkpoint checkpoint = errorReporter.checkpoint();
  }
  tagEnd = <CMD_END>
  {
    SourceLocation location = createSrcLoc(tagBegin, tagEnd);
    MsgFallbackGroupNode msgFbGrpNode = new MsgFallbackGroupNode(nodeIdGen.genId(), location);
    msgNode = MsgNode.msg(nodeIdGen.genId(), cmdText, location).build(context);
    msgFbGrpNode.addChild(msgNode);
  }
  templateBlockForMsg = TemplateBlockForMsg()
  { msgNode.addChildren(templateBlockForMsg); }

  (
    tagBegin = <CMD_BEGIN_FALLBACK_MSG>
    cmdText = CmdText()
    tagEnd = <CMD_END>
    {
     location = createSrcLoc(tagBegin, tagEnd);
      msgNode = MsgNode.fallbackmsg(nodeIdGen.genId(), cmdText, location).build(context);
      msgFbGrpNode.addChild(msgNode);
    }
    templateBlockForMsg = TemplateBlockForMsg()
    { msgNode.addChildren(templateBlockForMsg); }
  )?

  {
    if (errorReporter.errorsSince(checkpoint) || getToken(1).kind != CMD_CLOSE_MSG) {
      popStateIfStateIs(TEMPLATE_DEFAULT_IN_MSG_BLOCK);
    } else {
      popState();
    }
  }
  <CMD_CLOSE_MSG>

  { return msgFbGrpNode; }
}


/**
 * TemplateBlockForMsg ->   (Whitespace) MsgPlural MaybeWhitespace
 *                        | MaybeWhitespace MsgSelect MaybeWhitespace
 *                        | ( ContiguousRawTextAsNode | Stmt | MsgHtmlTag )*
 */
private List<StandaloneNode> TemplateBlockForMsg() :
{
  RawTextNode rawText;
  MsgPlaceholderInitialNode stmt;
  MsgPlaceholderInitialNode msgHtmlTag;
  StandaloneNode msgPluralOrSelectNode;
  // The index of the plural or select node, if any
  int pluralOrSelectIndex = -1;
  // Whether or not the first node is just whitespace.
  boolean firstNodeIsWhitespace = false;
  List<StandaloneNode> templateBlock = Lists.newArrayList();
}
{
  // For template blocks, we have two different options.
  // 1. simple: a mix of raw text and place holders
  // 2. plurals and genders.
  //
  // Plurals and genders use the {plural} and {select} tags which work like {switch} statements but
  // they require that that are only preceeded and succeeded by whitespace.  To handle parsing this
  // without a non-trivial lookahead we search for and collect all initial whitespace into a special
  // raw text node.  This will allow us to trivially ignore it if we do parse a following {plural
  // or to just use it as a normal rawtextnode if we don't.

  // try to collect all leading whitespace into a raw text node on its own.
  // This will make it possible to detect if a leading {plural} or {select} was preceeded by content
  [ LOOKAHEAD(1)  // prefer taking this branch over skipping and consuming as RawText
    { Token tok;
      RawTextBuilder builder = new RawTextBuilder(filePath, nodeIdGen);
    }
    ( LOOKAHEAD(1)  // prefer staying in the loop
      tok = <TOKEN_WS>
      { builder.addBasic(tok); }
    )+
    {
      rawText = builder.build();
      if (rawText != null) {
        firstNodeIsWhitespace = true;
        templateBlock.add(rawText);
      }
    }
  ]
  (
    (
      msgPluralOrSelectNode = MsgPlural()
    | msgPluralOrSelectNode = MsgSelect()
    )
    SkipWhitespace()  // we want to ignore all whitespace after a plural or select, just expect it
  {
    if (firstNodeIsWhitespace) {
      // The first node was just basic whitespace.  Which is allowed but ignored prior to a plural
      // or select.  So just drop it.
      templateBlock.remove(0);
      firstNodeIsWhitespace = false;
    }
    if (pluralOrSelectIndex == -1) {
      pluralOrSelectIndex = templateBlock.size();
    }
    templateBlock.add(msgPluralOrSelectNode);
  }
  | rawText = RawText() { templateBlock.add(rawText); }
  | stmt = CallStmt()  { templateBlock.add(new MsgPlaceholderNode(nodeIdGen.genId(), stmt)); }
  | stmt = PrintStmt() { templateBlock.add(new MsgPlaceholderNode(nodeIdGen.genId(), stmt)); }
  | msgHtmlTag = MsgHtmlTag()
    { templateBlock.add(new MsgPlaceholderNode(nodeIdGen.genId(), msgHtmlTag)); }
  )*

  {
    // Plural/select are only allowed if they are the only child
    // However we do allow them to be prefixed or suffixed with arbitrary amounts of whitespace.
    if (pluralOrSelectIndex != -1) {
      StandaloneNode pluralOrSelect = templateBlock.get(pluralOrSelectIndex);
      for (int i = 0; i < templateBlock.size(); i++) {
        if (i == pluralOrSelectIndex) {
          continue;
        }
        errorReporter.report(
          // blame the current node
          templateBlock.get(i).getSourceLocation(),
          i < pluralOrSelectIndex ? UNEXPECTED_CONTENT_BEFORE : UNEXPECTED_CONTENT_AFTER,
          pluralOrSelect instanceof MsgPluralNode ? "{plural" : "{select");
      }
      // return the single plural or select and drop the other items.  We have either reported
      // errors or have ignored them because they are purely whitespace.
      return ImmutableList.of(pluralOrSelect);
    }
    return templateBlock;
  }
}


/**
 * MsgPlural -> PluralTag MaybeWhitespace ( CaseTag TemplateBlockForMsg )*
 *              DefaultTag TemplateBlockForMsg EndPluralTag
 */
private MsgPluralNode MsgPlural() :
{
  String cmdText;
  List<StandaloneNode> templateBlock;
  Token cmdBegin, cmdEnd;
  Token defaultTag;
}
{
  cmdBegin = <CMD_BEGIN_PLURAL>
  cmdText = CmdText()
  cmdEnd = <CMD_END>
  {
    MsgPluralNode msgPluralNode = new MsgPluralNode.Builder(
        nodeIdGen.genId(), cmdText, createSrcLoc(cmdBegin, cmdEnd))
        .build(context);
  }
  try {
    // consume all whitespace between {plural} and the first {case}
    // later {case} and {default} tags will naturally consume whitespace due via RawText()
    SkipWhitespace()
    (
      cmdBegin = <CMD_BEGIN_CASE>
      cmdText = CmdText()
      cmdEnd = <CMD_END>
      {
        MsgPluralCaseNode msgPluralCaseNode = new MsgPluralCaseNode.Builder(
            nodeIdGen.genId(), cmdText, createSrcLoc(cmdBegin, cmdEnd))
            .build(errorReporter);
        msgPluralNode.addChild(msgPluralCaseNode);
      }
      templateBlock = TemplateBlockForMsg()
      { if (templateBlock.size() == 1 &&
            (templateBlock.get(0) instanceof MsgPluralNode ||
             templateBlock.get(0) instanceof MsgSelectNode )) {
          errorReporter.report(
              templateBlock.get(0).getSourceLocation(),
              PLURAL_AND_SELECT_NOT_ALLOWED_INSIDE_PLURAL_BLOCK);
        }
        msgPluralCaseNode.addChildren(templateBlock);
      }
    )*

    defaultTag = <CMD_FULL_DEFAULT>
    {
      MsgPluralDefaultNode msgPluralDefaultNode = new MsgPluralDefaultNode(
          nodeIdGen.genId(), createSrcLoc(defaultTag));
      msgPluralNode.addChild(msgPluralDefaultNode);
    }
    templateBlock = TemplateBlockForMsg()
    { if (templateBlock.size() == 1 &&
          (templateBlock.get(0) instanceof MsgPluralNode ||
           templateBlock.get(0) instanceof MsgSelectNode )) {
        errorReporter.report(
            templateBlock.get(0).getSourceLocation(),
            PLURAL_AND_SELECT_NOT_ALLOWED_INSIDE_PLURAL_BLOCK);
      }
      msgPluralDefaultNode.addChildren(templateBlock);
    }

    <CMD_CLOSE_PLURAL>
  } catch (ParseException e) {
    // report and keep going to maintain previous behavior around reporting errors for unexpected
    // textual content before the first {case} tag
    reportTemplateBodyErrorAndSkipTo(e, CMD_CLOSE_PLURAL);
  }

  { return msgPluralNode; }
}


/**
 * MsgSelect -> SelectTag MaybeWhitespace ( CaseTag TemplateBlockForMsg )*
 *              DefaultTag TemplateBlockForMsg EndSelectTag
 */
private MsgSelectNode MsgSelect() :
{
  Token defaultTag;
  String cmdText;
  List<StandaloneNode> templateBlock;
  Token cmdBegin, cmdEnd;
}
{
  cmdBegin = <CMD_BEGIN_SELECT>
  cmdText = CmdText()
  cmdEnd = <CMD_END>
  {
    MsgSelectNode msgSelectNode = new MsgSelectNode.Builder(
        nodeIdGen.genId(), cmdText, createSrcLoc(cmdBegin, cmdEnd)).build(context);
  }
  // consume all whitespace between {select} and the first {case}
  // later {case} and {default} tags will naturally consume whitespace due to RawText()
  SkipWhitespace()
  try {
    (
      cmdBegin = <CMD_BEGIN_CASE>
      cmdText = CmdText()
      cmdEnd = <CMD_END>
      {
        MsgSelectCaseNode msgSelectCaseNode = new MsgSelectCaseNode.Builder(
            nodeIdGen.genId(), cmdText, createSrcLoc(cmdBegin, cmdEnd))
            .build(context);
        msgSelectNode.addChild(msgSelectCaseNode);
      }
      templateBlock = TemplateBlockForMsg()
      { msgSelectCaseNode.addChildren(templateBlock); }
    )*

    defaultTag = <CMD_FULL_DEFAULT>
    {
      MsgSelectDefaultNode msgSelectDefaultNode
          = new MsgSelectDefaultNode(nodeIdGen.genId(), createSrcLoc(defaultTag));
      msgSelectNode.addChild(msgSelectDefaultNode);
    }
    templateBlock = TemplateBlockForMsg()
    { msgSelectDefaultNode.addChildren(templateBlock); }

    <CMD_CLOSE_SELECT>
  } catch (ParseException e) {
    reportTemplateBodyErrorAndSkipTo(e, CMD_CLOSE_SELECT);
  }

  { return msgSelectNode; }
}


/**
 * MsgHtmlTag -> MsgHtmlTagOpen TemplateBlock MsgHtmlTagClose
 */
private MsgHtmlTagNode MsgHtmlTag() :
{
  Token htmlTagOpen;
  List<StandaloneNode> templateBlock;
}
{
  htmlTagOpen = <MSG_HTML_TAG_OPEN>
  templateBlock = TemplateBlock()
  <MSG_HTML_TAG_CLOSE>

  {
    SourceLocation srcLoc = createSrcLoc(htmlTagOpen);
    // TODO(lukes): Massively simplify this by creating more nodes.  Also fix SourceLocation.
    // First, we add back the HTML tag's opening and closing angle brackets.
    // Minor note: If there's only one RawTextNode, we'll replace it twice. No big deal.
    if (templateBlock.get(0) instanceof RawTextNode) {
      RawTextNode firstNode = (RawTextNode) templateBlock.get(0);
      RawTextNode newNode = new RawTextNode(
          nodeIdGen.genId(),
          "<" + firstNode.getRawText(),
          srcLoc.extend(firstNode.getSourceLocation()));
      templateBlock.set(0, newNode);
    } else {
      templateBlock.add(0, new RawTextNode(nodeIdGen.genId(), "<", srcLoc));
    }
    int lastNodeIndex = templateBlock.size() - 1;
    if (templateBlock.get(lastNodeIndex) instanceof RawTextNode) {
      RawTextNode lastNode = (RawTextNode) templateBlock.get(lastNodeIndex);
      RawTextNode newNode =
          new RawTextNode(nodeIdGen.genId(), lastNode.getRawText() + ">",
          lastNode.getSourceLocation().extend(srcLoc));

      templateBlock.set(lastNodeIndex, newNode);
    } else {
      templateBlock.add(new RawTextNode(nodeIdGen.genId(), ">", srcLoc));
    }
    return new MsgHtmlTagNode.Builder(
        nodeIdGen.genId(),
        ImmutableList.copyOf(templateBlock),
        createSrcLoc(htmlTagOpen))
        .build(errorReporter);
  }
}


/**
 * PrintTag -> SoyTagOpen [ CmdNamePrint WsAfterCmdName ] CmdTextParts RegSoyTagClose
 *
 */
private SourceItemInfo<List<String>> PrintTag() :
{
  Token tagBegin, tagEnd;
  List<String> cmdTextParts;
  List<String> printTagParts = Lists.newArrayList();
}
{

  (
    tagBegin = <CMD_BEGIN_PRINT>  { printTagParts.add("print"); }
  | tagBegin = <CMD_BEGIN_IMPLICIT_PRINT>  // Implicit print
  )
  cmdTextParts = CmdTextParts()
  { printTagParts.addAll(cmdTextParts); }
  tagEnd = <CMD_END>

  {
    if (printTagParts.isEmpty()) {
      // This error is reported in the command, to catch both {print} and {}.
    } else if (printTagParts.get(0).startsWith("/")) {
      errorReporter.report(createSrcLoc(tagBegin, tagEnd), UNEXPECTED_CLOSING_TAG,
          "{" + Joiner.on("").join(printTagParts) + "}");
    } else if (printTagParts.get(0).startsWith("@")) {
      errorReporter.report(createSrcLoc(tagBegin, tagEnd), INVALID_DECLARATION,
          "{" + printTagParts.get(0));
    } else if (printTagParts.get(0).startsWith("{")) {
      errorReporter.report(createSrcLoc(tagBegin, tagEnd), FOUND_DOUBLE_BRACE);
    } else if (INVALID_PRINT_FILE_PREFIX_PATTERN.matcher(printTagParts.get(0)).matches()) {
      errorReporter.report(createSrcLoc(tagBegin, tagEnd), INVALID_PRINT_FILE_COMMAND,
          "{" + printTagParts.get(0));
    } else if (INVALID_PRINT_PREFIX_PATTERN.matcher(printTagParts.get(0)).matches()) {
      errorReporter.report(createSrcLoc(tagBegin, tagEnd), INVALID_PRINT_PREFIX,
          "{" + printTagParts.get(0));
    }
    return newSourceItemInfo(printTagParts, tagBegin, tagEnd);
  }
}

/**
 * PrintStmt -> PrintTag
 */
private PrintNode PrintStmt() :
{
  Token tagBegin, tagEnd;
  List<String> cmdTextParts;
  boolean isImplicit;
}
{
  (
    tagBegin = <CMD_BEGIN_PRINT>  { isImplicit = false; }
  | tagBegin = <CMD_BEGIN_IMPLICIT_PRINT>  { isImplicit = true; }
  )
  cmdTextParts = CmdTextParts()
  tagEnd = <CMD_END>
  {
    SourceLocation location = createSrcLoc(tagBegin, tagEnd);
    // This will also capture invalid forms of actual commands that did not match those commands'
    // actual tokens (eg, `{else blah}`), then try to parse them as implicit prints.  We check for
    // these errors here, catching any kind of invalid construction that starts with { and is not
    // matched by a token.
    if (cmdTextParts.isEmpty()) {
      errorReporter.report(location, PRINT_COMMAND_WITH_EMPTY_TEXT);
    } else if (cmdTextParts.get(0).startsWith("/")) {
      errorReporter.report(location, UNEXPECTED_CLOSING_TAG,
          "{" + Joiner.on("").join(cmdTextParts) + "}");
    } else if (cmdTextParts.get(0).startsWith("@")) {
      errorReporter.report(location, INVALID_DECLARATION, "{" + cmdTextParts.get(0));
    } else if (cmdTextParts.get(0).startsWith("{")) {
      errorReporter.report(location, FOUND_DOUBLE_BRACE);
    } else if (INVALID_PRINT_FILE_PREFIX_PATTERN.matcher(cmdTextParts.get(0)).matches()) {
      errorReporter.report(location, INVALID_PRINT_FILE_COMMAND, "{" + cmdTextParts.get(0));
    } else if (INVALID_PRINT_PREFIX_PATTERN.matcher(cmdTextParts.get(0)).matches()) {
      errorReporter.report(location, INVALID_PRINT_PREFIX, "{" + cmdTextParts.get(0));
    }

    // ------ Process command name (implicit or explicit). ------
    String cmdText = Joiner.on("").join(cmdTextParts);

    // ------ Process 'phname' attribute (if any). ------
    String phnameAttr = null;
    for (String cmdTextPart : cmdTextParts) {
      if (cmdTextPart.startsWith(" phname=\"") && cmdTextPart.endsWith("\"")) {
        if (phnameAttr != null) {
          errorReporter.report(location, MULTIPLE_PHNAME_ATTRIBUTES_IN_COMMAND, cmdText);
        }
        phnameAttr = cmdTextPart;
      }
    }
    String userSuppliedPhName;
    if (phnameAttr != null) {
      cmdTextParts.remove(phnameAttr);
      userSuppliedPhName = phnameAttr.substring(9, phnameAttr.length() - 1);
    } else {
      userSuppliedPhName = null;
    }

    // ------ Process expression. ------
    // Note: First part is expression, rest of parts are directives or directive args.
    // if cmdTextParts is empty, we already reported an error above, so pretend it is a literal
    // empty string and keep going.
    String exprText = cmdTextParts.isEmpty() ? "''" : cmdTextParts.get(0).trim();
    PrintNode printNode
        = new PrintNode.Builder(nodeIdGen.genId(), isImplicit, location)
            .exprText(exprText)
            .userSuppliedPlaceholderName(userSuppliedPhName)
            .build(context);

    // ------ Process directives (if any). ------
    String directiveName = null;
    for (int i = 1, n = cmdTextParts.size(); i < n; i++) {
      String cmdTextPart = cmdTextParts.get(i);

      if (cmdTextPart.startsWith("|")) {
        // Create previous directive and save current directive name.
        if (directiveName != null) {
          printNode.addChild(new PrintDirectiveNode.Builder(
              nodeIdGen.genId(), directiveName, "", location)
              .build(context));
        }
        directiveName = cmdTextPart;

      } else if (cmdTextPart.startsWith(":")) {
        // Create previous directive with current args text.
        if (directiveName == null) {
          throw new AssertionError();
        }
        String argsText = cmdTextPart.substring(1);
        printNode.addChild(new PrintDirectiveNode.Builder(
            nodeIdGen.genId(), directiveName, argsText, location)
            .build(context));
        directiveName = null;

      } else if (cmdTextPart.trim().length() == 0) {
        continue;

      } else {
        errorReporter.report(printNode.getSourceLocation(), INVALID_PRINT_COMMAND_TEXT, cmdText);
      }
    }
    // Add last directive.
    if (directiveName != null) {
      printNode.addChild(new PrintDirectiveNode.Builder(
          nodeIdGen.genId(), directiveName, "", location)
          .build(context));
    }

    return printNode;
  }
}


/**
 * XidStmt -> XidTag
 */
private XidNode XidStmt() :
{
  Token cmdBegin, cmdEnd;
  String cmdText;
}
{
  cmdBegin = <CMD_BEGIN_XID>
  cmdText = CmdText()
  cmdEnd = <CMD_END>
  {
    return new XidNode.Builder(nodeIdGen.genId(), cmdText, createSrcLoc(cmdBegin, cmdEnd))
        .build(errorReporter);
  }
}


/**
 * CssStmt -> CssTag
 */
private CssNode CssStmt() :
{
  Token cmdBegin, cmdEnd;
  String cmdText;
}
{
  cmdBegin = <CMD_BEGIN_CSS>
  cmdText = CmdText()
  cmdEnd = <CMD_END>
  {
    return new CssNode.Builder(nodeIdGen.genId(), cmdText, createSrcLoc(cmdBegin, cmdEnd))
        .build(context);
  }
}


/**
 * LetStmt -> <CMD_BEGIN_LET> CmdText() (<CMD_SELF_CLOSE>|<CMD_END> TemplateBlock() <CMD_CLOSE_LET>)
 */
private LetNode LetStmt() :
{
  SourceItemInfo<String> cmdText;
  Token tagBegin, tagEnd;
  LetNode letNode;
}
{
  tagBegin = <CMD_BEGIN_LET>
  cmdText = CmdTextWithSource()
  {
    Checkpoint cmdTextCheckpoint = errorReporter.checkpoint();
    LetNode.CommandTextParseResult result =
        LetNode.parseCommandTextHelper(
            cmdText.parsedContent(),
            context,
            cmdText.srcLocation());
  }
  (
    tagEnd = <CMD_SELF_CLOSE>

    { letNode = new LetValueNode.Builder(
          nodeIdGen.genId(), result, createSrcLoc(tagBegin, tagEnd))
          .build(cmdTextCheckpoint, errorReporter);
    }
  |
    {
      pushState(TEMPLATE_DEFAULT);
      Checkpoint checkpoint = errorReporter.checkpoint();
    }
    tagEnd = <CMD_END>
    { LetContentNode letContentNode = new LetContentNode.Builder(
          nodeIdGen.genId(), result, createSrcLoc(tagBegin, tagEnd))
          .build(cmdTextCheckpoint, errorReporter);
      List<StandaloneNode> templateBlock;
    }
    templateBlock = TemplateBlock()
    { letContentNode.addChildren(templateBlock);
      letNode = letContentNode;
    }
    {
      // if there was an error or there is about to be one, be more careful popping the stack.
      if (errorReporter.errorsSince(checkpoint) || getToken(1).kind != CMD_CLOSE_LET) {
        popStateIfStateIs(TEMPLATE_DEFAULT);
      } else {
        popState();
      }
    }
    <CMD_CLOSE_LET>
  )

  { return letNode; }
}


/**
 * IfStmt -> IfTag TemplateBlock ( ElseifTag TemplateBlock )* [ ElseTag TemplateBlock ] EndIfTag
 */
private IfNode IfStmt() :
{
  String cmdText;
  List<StandaloneNode> templateBlock;
  Token cmdBegin, cmdEnd;
  Token elseTag;
}
{
  { IfCondNode ifCondNode; }

  cmdBegin = <CMD_BEGIN_IF>
  cmdText = CmdText()
  cmdEnd = <CMD_END>
  {
    SourceLocation ifTagLocation = createSrcLoc(cmdBegin, cmdEnd);
    IfNode ifNode = new IfNode(nodeIdGen.genId(), ifTagLocation);
    ifCondNode = IfCondNode.ifBuilder(
        nodeIdGen.genId(), cmdText, ifTagLocation)
        .build(context);
    ifNode.addChild(ifCondNode);
  }
  templateBlock = TemplateBlock()
  { ifCondNode.addChildren(templateBlock); }

  (
    cmdBegin = <CMD_BEGIN_ELSEIF>
    cmdText = CmdText()
    cmdEnd = <CMD_END>
    {
      SourceLocation elseIfLocation = createSrcLoc(cmdBegin, cmdEnd);
      ifCondNode = IfCondNode.elseifBuilder(
          nodeIdGen.genId(), cmdText, elseIfLocation).build(context);
      ifNode.addChild(ifCondNode);
    }
    templateBlock = TemplateBlock()
    { ifCondNode.addChildren(templateBlock); }
  )*

  [

    elseTag = <CMD_FULL_ELSE>
    {
      IfElseNode ifElseNode = new IfElseNode(nodeIdGen.genId(), createSrcLoc(elseTag));
      ifNode.addChild(ifElseNode);
    }
    templateBlock = TemplateBlock()
    { ifElseNode.addChildren(templateBlock); }
  ]

  <CMD_CLOSE_IF>

  { return ifNode; }
}


/**
 * SwitchStmt -> SwitchTag MaybeWhitespace ( CaseTag TemplateBlock )* [ DefaultTag TemplateBlock ]
 *               EndSwitchTag
 */
private SwitchNode SwitchStmt() :
{
  String cmdText;
  List<StandaloneNode> templateBlock;
  Token cmdBegin, cmdEnd;
  Token defaultTag;
}
{
  cmdBegin = <CMD_BEGIN_SWITCH>
  cmdText = CmdText()
  cmdEnd = <CMD_END>
  {
    SwitchNode switchNode = new SwitchNode.Builder(
        nodeIdGen.genId(), cmdText, createSrcLoc(cmdBegin, cmdEnd))
        .build(context);
  }
  // consume all whitespace between {switch} and the first {case}
  // later {case} and {default} tags will naturally consume and drop whitespace due to how RawText()
  // line joining works
  SkipWhitespace()
  try {
    (
      cmdBegin = <CMD_BEGIN_CASE>
      cmdText = CmdText()
      cmdEnd = <CMD_END>
      {
        SwitchCaseNode switchCaseNode = new SwitchCaseNode.Builder(
            nodeIdGen.genId(), cmdText, createSrcLoc(cmdBegin, cmdEnd))
            .build(context);
        switchNode.addChild(switchCaseNode);
      }
      templateBlock = TemplateBlock()
      { switchCaseNode.addChildren(templateBlock); }
    )*

    [
      defaultTag = <CMD_FULL_DEFAULT>
      {
        SwitchDefaultNode switchDefaultNode = new SwitchDefaultNode(
            nodeIdGen.genId(), createSrcLoc(defaultTag));
        switchNode.addChild(switchDefaultNode);
      }
      templateBlock = TemplateBlock()
      { switchDefaultNode.addChildren(templateBlock); }
    ]

    <CMD_CLOSE_SWITCH>
 } catch (ParseException e) {
   reportTemplateBodyErrorAndSkipTo(e, CMD_CLOSE_SWITCH);
 }

  { return switchNode; }
}


/**
 * ForeachStmt -> ForeachTag TemplateBlock [ IfemptyTag TemplateBlock ] EndForeachTag
 */
private ForeachNode ForeachStmt() :
{
  String cmdText;
  List<StandaloneNode> templateBlock;
  Token cmdBegin, cmdEnd;
  Token ifemptyTag;
}
{
  cmdBegin = <CMD_BEGIN_FOREACH>
  cmdText = CmdText()
  cmdEnd = <CMD_END>
  {
    ForeachBuilder builder = ForeachBuilder.create(nodeIdGen, context)
        .setCommandLocation(createSrcLoc(cmdBegin, cmdEnd))
        .setCommandText(cmdText);
  }

  templateBlock = TemplateBlock()
  {
    builder.setLoopBody(templateBlock);
  }

  [
    ifemptyTag = <CMD_FULL_IFEMPTY>
    templateBlock = TemplateBlock()
    {
      builder.setIfEmptyBody(createSrcLoc(ifemptyTag), templateBlock);
    }
  ]

  <CMD_CLOSE_FOREACH>

  { return builder.build(); }
}


/**
 * ForStmt -> ForTag TemplateBlock EndForTag
 */
private ForNode ForStmt() :
{
  String cmdText;
  Token cmdBegin, cmdEnd;
  List<StandaloneNode> templateBlock;
}
{
  cmdBegin = <CMD_BEGIN_FOR>
  cmdText = CmdText()
  cmdEnd = <CMD_END>
  {
    ForNode forNode = new ForNode(
        nodeIdGen.genId(),
        cmdText,
        createSrcLoc(cmdBegin, cmdEnd),
        context);
  }

  templateBlock = TemplateBlock()
  { forNode.addChildren(templateBlock); }

  <CMD_CLOSE_FOR>

  { return forNode; }
}


/**
 * CallStmt ->
 *   <CMD_BEGIN_CALL> CmdTextParts() (<CMD_SELF_CLOSE> | <CMD_END> CallParams <CMD_CLOSE_CALL>)
 * | <CMD_BEGIN_DELCALL> CmdTextParts() (<CMD_SELF_CLOSE> | <CMD_END> CallParams <CMD_CLOSE_DELCALL>)
 */
private CallNode CallStmt() :
{
  Token tagBegin, tagEnd;
  List<String> cmdTextParts;
  CallNode callNode = null;
}
{
  (
    tagBegin = <CMD_BEGIN_CALL>
    cmdTextParts = CmdTextParts()
    (
      tagEnd = <CMD_SELF_CLOSE>
      { callNode =
          setCommandTextAndPlaceholderName(
              new CallBasicNode.Builder(nodeIdGen.genId(), createSrcLoc(tagBegin, tagEnd)),
              cmdTextParts)
              .build(context);
      }
    |
      tagEnd = <CMD_END>
      { callNode =
          setCommandTextAndPlaceholderName(
              new CallBasicNode.Builder(nodeIdGen.genId(), createSrcLoc(tagBegin, tagEnd)),
              cmdTextParts)
              .build(context);
      }
      try {
        AddParams(callNode)
        <CMD_CLOSE_CALL>
      } catch (ParseException e) {
        reportTemplateBodyErrorAndSkipTo(e, CMD_CLOSE_CALL);
      }
    )
  |
    tagBegin = <CMD_BEGIN_DELCALL>
    cmdTextParts = CmdTextParts()
    (
      tagEnd = <CMD_SELF_CLOSE>
      { callNode =
          setCommandTextAndPlaceholderName(
              new CallDelegateNode.Builder(nodeIdGen.genId(), createSrcLoc(tagBegin, tagEnd)),
              cmdTextParts)
              .build(context);
      }
    |
      tagEnd = <CMD_END>
      { callNode =
          setCommandTextAndPlaceholderName(
              new CallDelegateNode.Builder(nodeIdGen.genId(), createSrcLoc(tagBegin, tagEnd)),
              cmdTextParts)
              .build(context);
      }
      try {
        AddParams(callNode)
        <CMD_CLOSE_DELCALL>
      } catch (ParseException e) {
        reportTemplateBodyErrorAndSkipTo(e, CMD_CLOSE_DELCALL);
      }
    )
  )
  { return callNode; }
}

JAVACODE
/**
 * Interprets the cmdTextParts to extract the phname attribute (if any) and then set it into the
 * builder.
 *
 * <p>TODO(lukes): switch calls to use 'structured' parsing.  It would simplify a lot of this and
 * yield better error messages
 */
private CallNode.Builder setCommandTextAndPlaceholderName(
    CallNode.Builder builder,
    List<String> cmdTextParts) {
  StringBuilder cmdTextSb = new StringBuilder();
  String phnameAttr = null;
  for (int i = 0; i < cmdTextParts.size(); i++) {
    String cmdTextPart = cmdTextParts.get(i);
    if (cmdTextPart.startsWith(" phname=\"") && cmdTextPart.endsWith("\"")) {
      if (phnameAttr != null) {
        errorReporter.report(
            builder.getSourceLocation(),
            MULTIPLE_PHNAME_ATTRIBUTES_IN_COMMAND,
            Joiner.on("").join(cmdTextParts));
      }
      phnameAttr = cmdTextPart;
    } else {
      cmdTextSb.append(cmdTextPart);
    }
  }

  // 9 == the length of ' phname="'... yes this is lame
  String userSuppliedPhName =
        (phnameAttr != null) ? phnameAttr.substring(9, phnameAttr.length() - 1) : null;
  return builder.commandText(cmdTextSb.toString()).userSuppliedPlaceholderName(userSuppliedPhName);
}


private void AddParams(CallNode callNode) :
{
  CallParamNode callParam;
}
{
  // consume all whitespace between {call}/{delcall} and the first {param} as well as between params
  SkipWhitespace()
  (
    callParam = CallParam()
    { callNode.addChild(callParam); }
    SkipWhitespace()
  )*
}


/**
 * CallParam -> <CMD_BEGIN_PARAM> CmdText() (<CMD_SELF_CLOSE>|<CMD_END> TemplateBlock() <CMD_CLOSE_PARAM>)
 */
private CallParamNode CallParam() :
{
  Token tagBegin, tagEnd;
  SourceItemInfo<String> cmdText;
  CallParamNode callParamNode = null;
}
{
  tagBegin = <CMD_BEGIN_PARAM>
  cmdText = CmdTextWithSource()
  {
    Checkpoint cmdTextCheckpoint = errorReporter.checkpoint();
    CallParamNode.CommandTextParseResult result =
        CallParamNode.parseCommandTextHelper(
            cmdText.parsedContent(),
            context,
            cmdText.srcLocation());
  }
  (
    tagEnd = <CMD_SELF_CLOSE>
    {
      callParamNode = new CallParamValueNode.Builder(
          nodeIdGen.genId(), result, createSrcLoc(tagBegin, tagEnd))
          .build(cmdTextCheckpoint, errorReporter);
    }
  |
    {
      pushState(TEMPLATE_DEFAULT);
      Checkpoint checkpoint = errorReporter.checkpoint();
    }
    tagEnd = <CMD_END>
    {
      CallParamContentNode cpcn = new CallParamContentNode.Builder(
          nodeIdGen.genId(), result, createSrcLoc(tagBegin, tagEnd))
          .build(cmdTextCheckpoint, errorReporter);
      List<StandaloneNode> templateBlock;
    }
    templateBlock = TemplateBlock()
    { cpcn.addChildren(templateBlock);
      callParamNode = cpcn;
    }
    {
      if (errorReporter.errorsSince(checkpoint) || getToken(1).kind != CMD_CLOSE_PARAM) {
        popStateIfStateIs(TEMPLATE_DEFAULT);
      } else {
        popState();
      }
    }
    <CMD_CLOSE_PARAM>
  )

  { return callParamNode; }
}


/**
 * LogStmt -> LogTag TemplateBlock EndLogTag
 */
private LogNode LogStmt() :
{
  Token open;
  List<StandaloneNode> templateBlock;
}
{
  open = <CMD_OPEN_LOG>
  {
    LogNode logNode = new LogNode(nodeIdGen.genId(), createSrcLoc(open));
  }

  templateBlock = TemplateBlock()
  { logNode.addChildren(templateBlock); }

  <CMD_CLOSE_LOG>

  { return logNode; }
}


/**
 * DebuggerStmt -> DebuggerTag TemplateBlock EndDebuggerTag
 */
private DebuggerNode DebuggerStmt() :
{
  Token token;
}
{
  token = <CMD_FULL_DEBUGGER>
  { return new DebuggerNode(nodeIdGen.genId(), createSrcLoc(token)); }
}



// -------------------------------------------------------------------------------------------------
// Type Expressions.
//
// The Soy type grammar is relatively simple.  We have 1 'operator' "|" for type unions, but other
// than that, it is just a small set of primary productions that are relatively unambiguous
//
// The most complex part of this is our handling of generic types since there is a small amount of
// ambiguity with nominal types because both start with a single identifier.  In the past this was
// handled by making our token definitions more complex, but this is generally antithetical to
// performance.
//
// NOTE: all the tokens we are consuming are defined in the EXPR lexical state.

/**
 * TypeExpr -> Primary ("|" Primary)*
 */
private TypeNode TypeExpr() :
{
  TypeNode first = null;
  TypeNode next = null;
  // lazily allocate the list since most of the time this isn't actually a Union
  List<TypeNode> members = null;
}
{
  first = PrimaryType()

  (
    <VBAR>
    next = PrimaryType()
    {
      if (members == null) {
        members = new ArrayList<TypeNode>();
        members.add(first);
      }
      members.add(next);
    }
  )*

  {
    return members == null ? first : UnionTypeNode.create(members);
  }
}


/**
 * Primary -> NamedType | UnknownType | RecordType
 */
private TypeNode PrimaryType() :
{
  TypeNode type;
}
{
  (
    type = NamedType()
  |
    type = UnknownType()
  |
    type = RecordType()
  )

  { return type; }
}


/**
 * RecordType -> "[" ( RecordField ( "," RecordField )* )? "]"
 */
private TypeNode RecordType() :
{
  List<RecordTypeNode.Property> properties = ImmutableList.of();
  Token open, close;
  RecordTypeNode.Property prop;
}
{
  open = <LBRACKET>

  (
    prop = RecordField()
    {
      properties = new ArrayList<RecordTypeNode.Property>();
      properties.add(prop);
    }
    (
      <COMMA>
      prop = RecordField()
      {
        properties.add(prop);
      }
    )*

  )?

  close = <RBRACKET>

  {
   return RecordTypeNode.create(createSrcLoc(open, close), properties);
  }
}


/**
 * RecordField -> NAME ":" TypeExpr
 */
private RecordTypeNode.Property RecordField() :
{
  Token fieldName;
  TypeNode fieldType;
}
{
  fieldName = <NAME>
  <COLON>
  fieldType = TypeExpr()

  {
    return RecordTypeNode.Property.create(createSrcLoc(fieldName), fieldName.image, fieldType);
  }
}


/**
 * NamedType -> IDENT ("." IDENT)* [< TypExpr() ("," TypeExpr())* >]
 *
 * <p>This includes any named type including our generic types
 */
private TypeNode NamedType() :
{
  Token first, open, close;
  Token next = null;
  String ident;
  SourceLocation fullLocation;

  TypeNode arg;
  List<TypeNode> genericArgs = ImmutableList.of();
  StringBuilder sb = null;
}
{

  first = <NAME>
  (
    <DOT>
    next = <NAME>
    {
      if (sb == null) {
        sb = new StringBuilder(first.image);
      }
      sb.append('.');
      sb.append(next.image);
    }
  )*
  {
    ident = sb == null ? first.image : sb.toString();
    fullLocation = next == null ? createSrcLoc(first) : createSrcLoc(first, next);
  }

  [
    open = <LANGLE>
    [
      arg = TypeExpr()
      {
        genericArgs = new ArrayList<TypeNode>();
        genericArgs.add(arg);
      }
      (
        <COMMA>
        arg = TypeExpr()
        {
          genericArgs.add(arg);
        }
      )*
    ]
    close = <RANGLE>
    {
      return GenericTypeNode.create(
          fullLocation.extend(createSrcLoc(close)),
          ident,
          genericArgs);
    }
  ]
  {
    return NamedTypeNode.create(fullLocation, ident);
  }
}

/**
 * UnknownType -> QMARK
 */
private TypeNode UnknownType() :
{
  Token tok;
}
{
  tok = <QMARK>
  { return NamedTypeNode.create(createSrcLoc(tok), "?"); }
}
